// Contract configuration options
options {
  // Arkade operator key (always external, never a contract party)
  server = operator;
  
  // Exit timelock: 24 hours (144 blocks)
  exit = 144;
}

// Fuji Safe Contract
contract FujiSafe(
  // The asset commitment hash (client-side validated)
  bytes assetCommitmentHash,
  // The amount being borrowed
  int borrowAmount,
  // The borrower's public key
  pubkey borrowerPk,
  // The treasury's public key
  pubkey treasuryPk,
  // The expiration timeout in blocks
  int expirationTimeout,
  // The price level for liquidation
  int priceLevel,
  // The setup timestamp
  int setupTimestamp,
  // The oracle's public key
  pubkey oraclePk,
  // The asset pair identifier
  bytes assetPair
) {
  // Helper function to verify Fuji token burning via Taproot output
  // Takes the pubkey to use as the internal key for the P2TR output
  function verifyFujiBurning(pubkey internalKey) internal {
    // In Taproot, we verify the output is a P2TR that commits to our asset
    // Using the provided pubkey as the internal key
    bytes p2trScript = new P2TR(internalKey, assetCommitmentHash);
    
    // Verify output 0 has the correct P2TR scriptPubKey and value
    require(tx.outputs[0].scriptPubKey == p2trScript, "P2TR output mismatch");
    require(tx.outputs[0].value == borrowAmount, "Value mismatch");
  }

  // Claim: Treasury can unlock all collateral after expiration when burning Fuji
  function claim(signature treasurySig) {
    // Check that expiration timeout has passed
    require(tx.time >= expirationTimeout, "Expiration timeout not reached");
    
    // Verify burning of Fuji token using treasury key
    verifyFujiBurning(treasuryPk);
    
    // Require treasury signature
    require(checkSig(treasurySig, treasuryPk), "Invalid treasury signature");
  }
  
  // Liquidation: Treasury can unlock all collateral with attestation price below the liquidation target
  function liquidate(int currentPrice, signature oracleSig, signature treasurySig) {
    // Check price is below liquidation threshold
    require(currentPrice < priceLevel, "Price not below liquidation threshold");
    
    // Verify timestamp is after setup
    require(tx.time >= setupTimestamp, "Timestamp before setup");
    
    // Create message for oracle signature verification
    bytes message = sha256(assetPair);
    
    // Verify oracle signature on price data
    require(checkSigFromStack(oracleSig, oraclePk, message), "Invalid oracle signature");
    
    // Verify burning of Fuji token using treasury key
    verifyFujiBurning(treasuryPk);
    
    // Require treasury signature
    require(checkSig(treasurySig, treasuryPk), "Invalid treasury signature");
  }
  
  // Private Redemption: Only owner can unlock all collateral with key when burning Fuji
  function redeem(signature borrowerSig) {
    // Verify burning of Fuji token using borrower key
    verifyFujiBurning(borrowerPk);
    
    // Require borrower signature
    require(checkSig(borrowerSig, borrowerPk), "Invalid borrower signature");
  }
  
  // Treasury Renew: Treasury can unilaterally renew the expiration time
  function renew(signature treasurySig) {
    int currentValue = tx.input.current.value;

    // Recreate same contract with identical parameters
    require(
      tx.outputs[0].scriptPubKey == new FujiSafe(
        assetCommitmentHash, borrowAmount, borrowerPk, treasuryPk,
        expirationTimeout, priceLevel, setupTimestamp, oraclePk, assetPair
      ),
      "contract mismatch"
    );
    require(tx.outputs[0].value == currentValue, "Value mismatch");

    // Require treasury signature
    require(checkSig(treasurySig, treasuryPk), "Invalid treasury signature");
  }
} 