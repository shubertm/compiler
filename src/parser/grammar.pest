// Whitespace and comments are silently consumed
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n" }

// Main entry point - must consume the entire input
main = { SOI ~ contract ~ EOI }

// Contract definition with strict structure and optional options block
contract = {
    options_block? ~
    "contract" ~ identifier ~
    "(" ~ param_list ~ ")" ~
    "{" ~ function* ~ "}"
}

// Options block for contract configuration
options_block = {
    "options" ~ "{" ~ (option_setting ~ ";")* ~ "}"
}

// Option setting with assignment
option_setting = {
    identifier ~ "=" ~ (number_literal | identifier | string_literal)
}

// Parameter list with proper comma separation
param_list = {
    (parameter ~ ("," ~ parameter)*)?
}

// Parameter definition
parameter = { data_type ~ identifier }

// Supported data types - atomic rule to prevent partial matches
// Note: longer types must come before shorter prefixes (bytes32/bytes20 before bytes)
// Array types use [] suffix (e.g., pubkey[], signature[])
base_type = @{ "pubkey" | "signature" | "bytes32" | "bytes20" | "bytes" | "asset" | "int" | "bool" }
data_type = { base_type ~ ("[]")? }

// Function definition with strict structure
function = {
    "function" ~ identifier ~
    "(" ~ param_list ~ ")" ~
    function_modifier? ~
    "{" ~ statement* ~ "}"
}

// Function modifier (internal, etc.)
function_modifier = { "internal" }

// Statement types - order matters, more specific first
statement = _{
    if_stmt |
    for_stmt |
    let_binding |
    var_assign |
    require_stmt |
    function_call_stmt |
    variable_declaration
}

// If statement with optional else
if_stmt = {
    "if" ~ "(" ~ general_expression ~ ")" ~ block ~ ("else" ~ block)?
}

// For loop statement (compile-time unrolled)
for_stmt = {
    "for" ~ "(" ~ identifier ~ "," ~ identifier ~ ")" ~ "in" ~ general_expression ~ block
}

// Block of statements
block = { "{" ~ statement* ~ "}" }

// Let binding (new variable with let keyword)
let_binding = {
    "let" ~ identifier ~ "=" ~ general_expression ~ ";"
}

// Variable assignment (reassignment without let keyword)
// Must check for = but not == or >= or <=
var_assign = {
    identifier ~ "=" ~ !("=") ~ general_expression ~ ";"
}

// Require statement
require_stmt = {
    "require" ~ "(" ~ complex_expression ~ ("," ~ string_literal)? ~ ")" ~ ";"
}

// Function call statement
function_call_stmt = {
    identifier ~ "(" ~ (complex_expression ~ ("," ~ complex_expression)*)? ~ ")" ~ ";"
}

// Variable declaration (typed, legacy support)
variable_declaration = {
    data_type ~ identifier ~ "=" ~ complex_expression ~ ";"
}

// General expression with operator precedence
// Used in conditions, let bindings, and assignments
general_expression = { comparison_expr }

// Comparison expressions (lowest precedence)
comparison_expr = {
    additive_expr ~ (comparison_operator ~ additive_expr)?
}

// Additive expressions (+ and -)
additive_expr = {
    multiplicative_expr ~ ((add_op | sub_op) ~ multiplicative_expr)*
}

// Multiplicative expressions (* and /)
multiplicative_expr = {
    unary_expr ~ ((mul_op | div_op) ~ unary_expr)*
}

// Unary and primary expressions
unary_expr = { primary_expr }

// Primary expressions (atoms)
primary_expr = {
    "(" ~ general_expression ~ ")" |
    check_sig_from_stack_verify |
    check_sig_from_stack |
    check_sig |
    sha256_initialize |
    sha256_update |
    sha256_finalize |
    sha256_func |
    neg64_func |
    le64_to_script_num |
    le32_to_le64 |
    ec_mul_scalar_verify |
    tweak_verify |
    asset_at |
    asset_count |
    asset_lookup |
    input_introspection |
    output_introspection |
    tx_introspection |
    tx_property_access |
    this_property_access |
    p2tr_constructor |
    function_call |
    array_index_access |
    number_literal |
    identifier
}

// Array indexing: identifier[index]
array_index_access = {
    identifier ~ "[" ~ (identifier | number_literal) ~ "]"
}

// Operators
comparison_operator = { ">=" | "<=" | "==" | "!=" | ">" | "<" }
add_op = { "+" }
sub_op = { "-" }
mul_op = { "*" }
div_op = { "/" }

// Complex expression types (for require statements)
// PEG ordered choice: first matching alternative wins
complex_expression = _{
    check_sig_from_stack_verify |
    check_sig_from_stack |
    check_sig |
    check_multisig |
    time_comparison |
    hash_comparison |
    asset_lookup_comparison |
    asset_count_comparison |
    asset_at_comparison |
    input_introspection_comparison |
    output_introspection_comparison |
    tx_introspection_comparison |
    group_property_comparison |
    property_comparison |
    identifier_comparison |
    binary_operation |
    sha256_initialize |
    sha256_update |
    sha256_finalize |
    neg64_func |
    le64_to_script_num |
    le32_to_le64 |
    ec_mul_scalar_verify |
    tweak_verify |
    asset_at |
    asset_count |
    asset_lookup |
    input_introspection |
    output_introspection |
    tx_introspection |
    asset_group_access |
    p2tr_constructor |
    tx_property_access |
    this_property_access |
    function_call |
    identifier |
    number_literal |
    array_literal
}

// ─── Asset Lookups ─────────────────────────────────────────────────────────────

// Asset lookup on inputs/outputs: tx.inputs[i].assets.lookup(assetId)
asset_lookup = {
    "tx" ~ "." ~ asset_lookup_source ~ array_access ~ "." ~ "assets" ~ "." ~ "lookup" ~ "(" ~ identifier ~ ")"
}

// Asset count: tx.inputs[i].assets.length or tx.outputs[o].assets.length
asset_count = {
    "tx" ~ "." ~ asset_lookup_source ~ array_access ~ "." ~ "assets" ~ "." ~ "length"
}

// Indexed asset access: tx.outputs[o].assets[t].property
// Returns assetId (txid32, gidx_u16) or amount (u64)
asset_at = {
    "tx" ~ "." ~ asset_lookup_source ~ array_access ~ "." ~ "assets" ~ array_access ~ "." ~ asset_at_property
}

// Properties for asset_at
asset_at_property = { "assetId" | "amount" }

// Source of asset lookup (inputs or outputs)
asset_lookup_source = { "inputs" | "outputs" }

// Asset lookup comparison: asset_lookup op expression
// Handles: tx.inputs[0].assets.lookup(id) >= 0
//          tx.outputs[0].assets.lookup(id) >= tx.inputs[0].assets.lookup(id)
//          tx.outputs[0].assets.lookup(id) >= tx.inputs[0].assets.lookup(id) + amount
asset_lookup_comparison = {
    asset_lookup ~ binary_operator ~ (asset_lookup_arith_expr | asset_lookup | identifier | number_literal)
}

// Asset count comparison: asset_count op expression
// Handles: tx.outputs[0].assets.length >= 1
asset_count_comparison = {
    asset_count ~ binary_operator ~ (identifier | number_literal)
}

// Asset at comparison: asset_at op expression
// Handles: tx.outputs[0].assets[0].amount >= minAmount
asset_at_comparison = {
    asset_at ~ binary_operator ~ (asset_at | identifier | number_literal)
}

// Arithmetic expression in asset lookup context (e.g., lookup + amount)
asset_lookup_arith_expr = {
    (asset_lookup | identifier | number_literal) ~ ("+" | "-" | "*" | "/") ~ (asset_lookup | identifier | number_literal)
}

// ─── Transaction Introspection ─────────────────────────────────────────────────

// Transaction-level introspection: tx.version, tx.locktime, tx.numInputs, tx.numOutputs, tx.weight
tx_introspection = {
    "tx" ~ "." ~ tx_introspection_property
}

// Transaction introspection properties
tx_introspection_property = { "version" | "locktime" | "numInputs" | "numOutputs" | "weight" }

// Transaction introspection comparison: tx_introspection op expression
tx_introspection_comparison = {
    tx_introspection ~ binary_operator ~ (identifier | number_literal)
}

// ─── Indexed Input/Output Introspection ─────────────────────────────────────────

// Input introspection: tx.inputs[i].property (value, scriptPubKey, sequence, outpoint, issuance)
input_introspection = {
    "tx" ~ "." ~ "inputs" ~ array_access ~ "." ~ input_introspection_property
}

// Input introspection properties (excluding asset - use .assets.* API instead)
input_introspection_property = { "value" | "scriptPubKey" | "sequence" | "outpoint" | "issuance" }

// Output introspection: tx.outputs[o].property (value, scriptPubKey, nonce)
output_introspection = {
    "tx" ~ "." ~ "outputs" ~ array_access ~ "." ~ output_introspection_property
}

// Output introspection properties (excluding asset - use .assets.* API instead)
output_introspection_property = { "value" | "scriptPubKey" | "nonce" }

// Input introspection comparison: input_introspection op expression
input_introspection_comparison = {
    input_introspection ~ binary_operator ~ (input_introspection | output_introspection | tx_property_access | this_property_access | p2tr_constructor | identifier | number_literal)
}

// Output introspection comparison: output_introspection op expression
output_introspection_comparison = {
    output_introspection ~ binary_operator ~ (input_introspection | output_introspection | tx_property_access | this_property_access | p2tr_constructor | identifier | number_literal)
}

// ─── Asset Groups ──────────────────────────────────────────────────────────────

// Asset group access: tx.assetGroups.find(id), tx.assetGroups.length,
// tx.assetGroups[k].sumInputs, etc.
asset_group_access = {
    "tx" ~ "." ~ "assetGroups" ~ (
        "." ~ "find" ~ "(" ~ identifier ~ ")" |
        "." ~ "length" |
        array_access ~ "." ~ group_property
    )
}

// Group property names — atomic to prevent partial matches
group_property = @{
    "sumInputs" | "sumOutputs" | "delta" | "control" | "metadataHash" | "assetId" | "isFresh"
}

// Group property comparison: variable.property op expression
// Matches patterns like: tokenGroup.delta == amount, tokenGroup.sumOutputs >= 0
// Also supports: group.sumOutputs >= group.sumInputs (both sides can have group property)
// Also supports: group.sumInputs >= group.sumOutputs + amount (arithmetic on right side)
group_property_comparison = {
    identifier ~ "." ~ group_property ~ binary_operator ~ (group_property_arith_expr | identifier_property_access | asset_lookup | asset_group_access | identifier | number_literal)
}

// Arithmetic expression with group properties: group.property +/- value
group_property_arith_expr = {
    identifier_property_access ~ arith_op ~ (identifier | number_literal)
}

// Arithmetic operator for group property expressions
arith_op = { "+" | "-" }

// Identifier property access: variable.property (e.g., group.sumInputs, tokenGroup.delta)
identifier_property_access = {
    identifier ~ "." ~ group_property
}

// ─── Standard Comparisons ──────────────────────────────────────────────────────

// Time comparison (tx.time >= timelock)
time_comparison = {
    "tx.time" ~ ">=" ~ identifier
}

// Identifier comparison (identifier operator identifier)
identifier_comparison = {
    identifier ~ binary_operator ~ identifier
}

// Property comparison (property_access operator expression)
// Note: tx_property_access must come before identifier to avoid partial matching
property_comparison = {
    (tx_property_access | this_property_access) ~ binary_operator ~ (asset_lookup | tx_property_access | this_property_access | p2tr_constructor | number_literal | identifier)
}

// Hash comparison (sha256(preimage) == hash)
hash_comparison = {
    sha256_func ~ "==" ~ identifier
}

// Binary operations between literals or identifiers
binary_operation = {
    (number_literal ~ binary_operator ~ (identifier | number_literal)) |
    (identifier ~ binary_operator ~ (identifier | number_literal))
}

binary_operator = { ">=" | "<=" | "==" | "!=" | ">" | "<" | "+" | "-" | "*" | "/" }

// P2TR constructor
p2tr_constructor = {
    "new" ~ "P2TR" ~ "(" ~ p2tr_constructor_args ~ ")"
}

// Arguments for P2TR constructor
p2tr_constructor_args = {
    complex_expression ~ ("," ~ complex_expression)*
}

// ─── Transaction Property Access ───────────────────────────────────────────────

// Transaction property access with special handling
tx_property_access = {
    "tx" ~ "." ~ tx_property_body
}

// Body of tx property access - separated to control greediness
tx_property_body = {
    // Input.current syntax - first-class support for current input introspection
    ("input" ~ "." ~ "current" ~ ("." ~ identifier)*) |
    // Asset groups access: find, length, or indexed property access
    ("assetGroups" ~ (
        "." ~ "find" ~ "(" ~ identifier ~ ")" |
        "." ~ "length" |
        array_access ~ ("." ~ asset_group_property)?
    )?) |
    // Standard property access
    (tx_property_part ~ tx_property_suffix*)
}

// Suffix for tx property access - explicitly requires [ or .
tx_property_suffix = {
    array_access | ("." ~ tx_property_part)
}

// Asset group properties
asset_group_property = {
    "sumInputs" | "sumOutputs" | "delta" | "control" | "metadataHash" | "assetId" | "isFresh" | "length" | "find"
}

// This property access
this_property_access = {
    "this" ~ "." ~ this_property
}

// This properties
this_property = {
    "activeInputIndex" | "activeBytecode"
}

// Property part with various access types
tx_property_part = {
    tx_special_property | tx_method_call | identifier
}

// Special properties that have specific meaning
tx_special_property = {
    "time" | "inputs" | "outputs" | "version" | "locktime" | "currentInput" | "assetGroups"
}

// Array access with index - simplified to avoid parsing ambiguity
array_access = {
    "[" ~ (number_literal | identifier) ~ "]"
}

// Method call with optional arguments
tx_method_call = {
    identifier ~ "(" ~ method_args? ~ ")"
}

// Method arguments - simplified to avoid left recursion
method_args = {
    method_arg ~ ("," ~ method_arg)*
}

// Single method argument
method_arg = {
    number_literal | identifier
}

// Array literal
array_literal = {
    "[" ~ complex_expression ~ ("," ~ complex_expression)* ~ "]"
}

// Function call
function_call = {
    identifier ~ "(" ~ (complex_expression ~ ("," ~ complex_expression)*)? ~ ")"
}

// ─── Cryptographic Primitives ──────────────────────────────────────────────────

// CheckSig expression
check_sig = {
    "checkSig" ~ "(" ~ identifier ~ "," ~ identifier ~ ")"
}

// CheckSigFromStack expression
// Arguments can be identifiers or array access (e.g., oracles[i])
check_sig_from_stack = {
    "checkSigFromStack" ~ "(" ~ sig_arg ~ "," ~ sig_arg ~ "," ~ sig_arg ~ ")"
}

// Signature function argument: identifier or array access
sig_arg = { array_index_access | identifier }

// CheckMultisig expression
check_multisig = {
    "checkMultisig" ~ "(" ~ array ~ "," ~ array ~ ")"
}

// Array of identifiers
array = {
    "[" ~ identifier ~ ("," ~ identifier)* ~ "]"
}

// SHA256 function
sha256_func = {
    "sha256" ~ "(" ~ complex_expression ~ ")"
}

// ─── Streaming SHA256 ──────────────────────────────────────────────────

// Streaming SHA256 initialize: sha256Initialize(data) → OP_SHA256INITIALIZE
sha256_initialize = {
    "sha256Initialize" ~ "(" ~ (identifier | number_literal) ~ ")"
}

// Streaming SHA256 update: sha256Update(ctx, chunk) → OP_SHA256UPDATE
sha256_update = {
    "sha256Update" ~ "(" ~ identifier ~ "," ~ (identifier | number_literal) ~ ")"
}

// Streaming SHA256 finalize: sha256Finalize(ctx, lastChunk) → OP_SHA256FINALIZE
sha256_finalize = {
    "sha256Finalize" ~ "(" ~ identifier ~ "," ~ (identifier | number_literal) ~ ")"
}

// ─── Conversion & Arithmetic ───────────────────────────────────────────

// Negate 64-bit value: neg64(value) → OP_NEG64
neg64_func = {
    "neg64" ~ "(" ~ (identifier | number_literal) ~ ")"
}

// Convert LE64 to script number: le64ToScriptNum(value) → OP_LE64TOSCRIPTNUM
le64_to_script_num = {
    "le64ToScriptNum" ~ "(" ~ (identifier | number_literal) ~ ")"
}

// Convert LE32 to LE64: le32ToLe64(value) → OP_LE32TOLE64
le32_to_le64 = {
    "le32ToLe64" ~ "(" ~ (identifier | number_literal) ~ ")"
}

// ─── Crypto Opcodes ────────────────────────────────────────────────────

// EC scalar multiplication verify: ecMulScalarVerify(k, P, Q) → OP_ECMULSCALARVERIFY
ec_mul_scalar_verify = {
    "ecMulScalarVerify" ~ "(" ~ (identifier | number_literal) ~ "," ~ (identifier | number_literal) ~ "," ~ (identifier | number_literal) ~ ")"
}

// Tweak verification: tweakVerify(P, k, Q) → OP_TWEAKVERIFY
tweak_verify = {
    "tweakVerify" ~ "(" ~ (identifier | number_literal) ~ "," ~ (identifier | number_literal) ~ "," ~ (identifier | number_literal) ~ ")"
}

// CheckSigFromStack with verify: checkSigFromStackVerify(sig, pubkey, msg) → OP_CHECKSIGFROMSTACKVERIFY
check_sig_from_stack_verify = {
    "checkSigFromStackVerify" ~ "(" ~ sig_arg ~ "," ~ sig_arg ~ "," ~ sig_arg ~ ")"
}

// ─── Terminals ─────────────────────────────────────────────────────────────────

// Identifiers must start with a letter and can contain letters, numbers, and underscores
identifier = @{
    ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")*
}

// Number literals are sequences of digits
number_literal = @{
    ASCII_DIGIT+
}

// String literals are sequences of characters enclosed in double quotes
string_literal = @{
    "\"" ~ (!"\"" ~ ANY)* ~ "\""
}
