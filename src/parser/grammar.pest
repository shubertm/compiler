// Whitespace and comments are silently consumed
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n" }

// Main entry point - must consume the entire input
main = { SOI ~ contract ~ EOI }

// Contract definition with strict structure and optional options block
contract = { 
    options_block? ~
    "contract" ~ identifier ~ 
    "(" ~ param_list ~ ")" ~ 
    "{" ~ function* ~ "}" 
}

// Options block for contract configuration
options_block = {
    "options" ~ "{" ~ (option_setting ~ ";")* ~ "}"
}

// Option setting with assignment
option_setting = {
    identifier ~ "=" ~ (number_literal | identifier | string_literal)
}

// Parameter list with proper comma separation
param_list = { 
    (parameter ~ ("," ~ parameter)*)? 
}

// Parameter definition
parameter = { data_type ~ identifier }

// Supported data types - atomic rule to prevent partial matches
data_type = @{ "pubkey" | "signature" | "bytes" | "bytes20" | "bytes32" | "asset" | "int" | "bool" }

// Function definition with strict structure
function = { 
    "function" ~ identifier ~ 
    "(" ~ param_list ~ ")" ~ 
    function_modifier? ~
    "{" ~ (require_stmt | function_call_stmt | variable_declaration)* ~ "}" 
}

// Function modifier (internal, etc.)
function_modifier = { "internal" }

// Require statement
require_stmt = { 
    "require" ~ "(" ~ complex_expression ~ ("," ~ string_literal)? ~ ")" ~ ";" 
}

// Function call statement
function_call_stmt = {
    identifier ~ "(" ~ (complex_expression ~ ("," ~ complex_expression)*)? ~ ")" ~ ";"
}

// Variable declaration
variable_declaration = {
    data_type ~ identifier ~ "=" ~ complex_expression ~ ";"
}

// Complex expression types
complex_expression = _{ 
    check_sig_from_stack |
    check_sig | 
    check_multisig | 
    time_comparison |
    identifier_comparison |
    hash_comparison |
    property_comparison |
    binary_operation |
    p2tr_constructor |
    tx_property_access |
    this_property_access |
    function_call |
    identifier |
    number_literal |
    array_literal
}

// Time comparison (tx.time >= timelock)
time_comparison = {
    "tx.time" ~ ">=" ~ identifier
}

// Identifier comparison (identifier operator identifier)
identifier_comparison = {
    identifier ~ binary_operator ~ identifier
}

// Property comparison (property_access operator expression)
property_comparison = {
    (tx_property_access | this_property_access) ~ binary_operator ~ (identifier | number_literal | tx_property_access | this_property_access | p2tr_constructor)
}

// Hash comparison (sha256(preimage) == hash)
hash_comparison = {
    sha256_func ~ "==" ~ identifier
}

// Binary operations between literals or identifiers
binary_operation = {
    (number_literal ~ binary_operator ~ (identifier | number_literal)) |
    (identifier ~ binary_operator ~ (identifier | number_literal))
}

binary_operator = { "==" | "<" | ">" | ">=" | "<=" | "!=" | "+" | "-" | "*" | "/" }

// P2TR constructor
p2tr_constructor = {
    "new" ~ "P2TR" ~ "(" ~ p2tr_constructor_args ~ ")"
}

// Arguments for P2TR constructor
p2tr_constructor_args = {
    complex_expression ~ ("," ~ complex_expression)*
}

// Transaction property access with special handling
tx_property_access = {
    "tx" ~ "." ~ (
        // Input.current syntax - new first-class support
        ("input" ~ "." ~ "current" ~ ("." ~ identifier)*) |
        // Standard property access
        (tx_property_part ~ (array_access | ("." ~ tx_property_part))*)
    )
}

// This property access
this_property_access = {
    "this" ~ "." ~ this_property
}

// This properties
this_property = {
    "activeInputIndex" | "activeBytecode"
}

// Property part with various access types
tx_property_part = {
    tx_special_property | tx_method_call | identifier
}

// Special properties that have specific meaning
tx_special_property = { 
    "time" | "inputs" | "outputs" | "version" | "locktime" | "currentInput"
}

// Array access with index
array_access = {
    "[" ~ (number_literal | identifier | this_property_access | tx_special_property) ~ "]"
}

// Method call
tx_method_call = {
    identifier ~ "(" ~ ")"
}

// Array literal
array_literal = {
    "[" ~ complex_expression ~ ("," ~ complex_expression)* ~ "]"
}

// Function call
function_call = {
    identifier ~ "(" ~ (complex_expression ~ ("," ~ complex_expression)*)? ~ ")"
}

// CheckSig expression
check_sig = { 
    "checkSig" ~ "(" ~ identifier ~ "," ~ identifier ~ ")" 
}

// CheckSigFromStack expression
check_sig_from_stack = {
    "checkSigFromStack" ~ "(" ~ identifier ~ "," ~ identifier ~ "," ~ identifier ~ ")"
}

// CheckMultisig expression
check_multisig = { 
    "checkMultisig" ~ "(" ~ array ~ "," ~ array ~ ")" 
}

// Array of identifiers
array = { 
    "[" ~ identifier ~ ("," ~ identifier)* ~ "]" 
}

// SHA256 function
sha256_func = {
    "sha256" ~ "(" ~ complex_expression ~ ")"
}

// Identifiers must start with a letter and can contain letters, numbers, and underscores
identifier = @{ 
    ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* 
}

// Number literals are sequences of digits
number_literal = @{ 
    ASCII_DIGIT+ 
}

// String literals are sequences of characters enclosed in double quotes
string_literal = @{
    "\"" ~ (!"\"" ~ ANY)* ~ "\""
}
